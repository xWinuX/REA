#version 450

#include "../PixelGridComputeGlobals.glsl"

layout (push_constant) uniform PushConstant {
    uint ReadIndex;
};

layout (std430, set = 1, binding = 5) writeonly buffer s_c_si_MarchingSquares {
    uint numConnectedSegments;
    uint numSolidSegments;
    vec2 segments[NumMarchingSquareSegments * 2];
};

const uint caseLookup[16] = {
0, // 0000 0
3, // 0001 1
5, // 0010 2
2, // 0011 3
4, // 0100 4
7, // 0101 5
1, // 0110 6
6, // 0111 7
6, // 1000 8
1, // 1001 9
8, // 1010 10
4, // 1011 11
2, // 1100 12
5, // 1101 13
3, // 1110 14
0, // 1111 15
};

const bool connectionLookup[16][2] = {
{ false, false }, // 0000 0
{ true, false }, // 0001 1
{ true, false }, // 0010 2
{ true, false }, // 0011 3
{ true, false }, // 0100 4
{ false, true }, // 0101 5
{ false, false }, // 0110 6
{ false, false }, // 0111 7
{ false, false }, // 1000 8
{ false, false }, // 1001 9
{ false, true }, // 1010 10
{ true, false }, // 1011 11
{ true, false }, // 1100 12
{ false, false }, // 1101 13
{ false, false }, // 1110 14
{ false, false }, // 1111 15
};



const int edgeLookup[9][4] = {
{ -1, -1, -1, -1 }, // Nothing 0
{ 0, 2, -1, -1 }, // Column 1
{ 1, 3, -1, -1 }, // Row 2
{ 0, 3, -1, -1 }, // Bottom Left Corner 3
{ 1, 2, -1, -1 }, // Top Right Corner 4
{ 0, 1, -1, -1 }, // Bottom Right Corner 5
{ 2, 3, -1, -1 }, // Top Left Corner 6
{ 0, 1, 2, 3 }, // Diagonal Top Right to Bottom Left 7
{ 0, 3, 1, 2 }// Diagonal Top Left to Bottom Right 9
};

const vec2 edgeOffsets[4] = vec2[4](
    vec2(0.5f, 0.0f), // 0 -> midpoint of edge between 0 and 1
    vec2(1.0f, 0.5f), // 1 -> midpoint of edge between 1 and 2
    vec2(0.5f, 1.0f), // 2 -> midpoint of edge between 2 and 3
    vec2(0.0f, 0.5f)// 3 -> midpoint of edge between 3 and 0
);




const uint Vertical = 0;
const uint Horizontal = 1;
const uint DiagonalLeftToRight = 2;
const uint DiagonalRightToLeft = 3;

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main()
{
    uint simulationWidth = simulationData.simulationWidth;
    uint simulationHeight = simulationData.simulationHeight;

    if (gl_GlobalInvocationID.x >= ((simulationWidth + simulationHeight) * 3) - 2) {
        return;
    }

    uint direction = Vertical;
    ivec2 stepDirection = ivec2(0, 1);// Which direction will the cells step to cover one column/row/diagonal
    uvec2 position = uvec2(gl_GlobalInvocationID.x, 0);// Starting position of the iteration
    uint numIterations = simulationHeight;
    bool swapEndAndStart = false;

    // Vertical Iteration
    if (gl_GlobalInvocationID.x < simulationWidth) {
        direction = Vertical;
        stepDirection = ivec2(0, 1);
        position = uvec2(gl_GlobalInvocationID.x, 0);
        numIterations = simulationHeight;

        // Horizontal Iteration
    } else if (gl_GlobalInvocationID.x < simulationWidth + simulationHeight) {
        direction = Horizontal;
        stepDirection = ivec2(1, 0);
        position = uvec2(0, gl_GlobalInvocationID.x - simulationWidth);
        numIterations = simulationWidth;
        swapEndAndStart = true;
        // Diagonal Left to Right
    } else if (gl_GlobalInvocationID.x < simulationWidth + simulationHeight + (simulationWidth + simulationHeight - 1)) {
        direction = DiagonalLeftToRight;
        stepDirection = ivec2(1, -1);
        uint index = gl_GlobalInvocationID.x - (simulationWidth + simulationHeight);
        if (index < simulationHeight) {
            position = uvec2(0, index);
            numIterations = min(index + 1, min(simulationWidth, simulationHeight));
        } else {
            position = uvec2(index - simulationHeight + 1, simulationHeight - 1);
            numIterations = min(simulationWidth - (index - simulationHeight + 1), simulationHeight);
        }
        swapEndAndStart = true;

        // Diagonal Right to Left
    } else {
        direction = DiagonalRightToLeft;
        stepDirection = ivec2(-1, -1);
        uint index = gl_GlobalInvocationID.x - (simulationWidth + simulationHeight + (simulationWidth + simulationHeight - 1));
        if (index < simulationHeight) {
            position = uvec2(simulationWidth - 1, index);
            numIterations = min(index + 1, min(simulationWidth, simulationHeight));
        } else {
            position = uvec2(simulationWidth - (index - simulationHeight + 1), simulationHeight - 1);
            numIterations = min(simulationWidth - (index - simulationHeight + 1), simulationHeight);
        }
    }

    vec2 startPosition[2] = { vec2(0.0f), vec2(0.0f) };
    vec2 previousPosition[2] = { vec2(1.0f), vec2(1.0f) };
    uint previousCaseIndex[2] = { 16, 16 };
    uint previousCaseNumber[2] = { 16, 16 };

    for (int stepIndex = 0; stepIndex < numIterations; stepIndex++)
    {
        uint x = uint(position.x + stepDirection.x * stepIndex);
        uint y = uint(position.y + stepDirection.y * stepIndex);

        vec2 samplePosition = vec2(x, y);

        uint topRightX = (x + 1) % simulationWidth;
        uint topRightY = y;

        uint bottomLeftX = x;
        uint bottomLeftY = (y == 0) ? simulationHeight - 1 : y - 1;

        uint bottomRightX = topRightX;
        uint bottomRightY = bottomLeftY;

        uvec2 targetOffset = uvec2(simulationData.targetPosition);
        uint topLeftIndex = getGlobalIndex(x, y, simulationData.width, targetOffset);
        uint topRightIndex= getGlobalIndex(topRightX, topRightY, simulationData.width, targetOffset);
        uint bottomLeftIndex = getGlobalIndex(bottomLeftX, bottomLeftY, simulationData.width, targetOffset);
        uint bottomRightIndex= getGlobalIndex(bottomRightX, bottomRightY, simulationData.width, targetOffset);

        Pixel topLeftPixel = pixels[topLeftIndex];
        Pixel topRightPixel = pixels[topRightIndex];
        Pixel bottomLeftPixel = pixels[bottomLeftIndex];
        Pixel bottomRightPixel = pixels[bottomRightIndex];

        bool isBoundary = x < 3     || x > simulationWidth-4    || y < 3    || y > simulationHeight-4;
        bool isBoundaryY = x < 3    || x > simulationWidth-4    || y-1 < 3  || y-1 > simulationHeight-4;
        bool isBoundaryX = x+1 < 3  || x+1 > simulationWidth-4  || y < 3    || y > simulationHeight-4;
        bool isBoundaryXY = x+1 < 3 || x+1 > simulationWidth-4  || y-1 < 3  || y-1 > simulationHeight-4;

        uint topLeftPixelFlags = isBoundary ? 0 : getFlags(topLeftPixel.PixelID16_Charge8_Flags8);
        uint topRightPixelFlags = isBoundaryX ? 0 : getFlags(topRightPixel.PixelID16_Charge8_Flags8);
        uint bottomLeftPixelFlags = isBoundaryY ? 0 : getFlags(bottomLeftPixel.PixelID16_Charge8_Flags8);
        uint bottomRightPixelFlags = isBoundaryXY ? 0 : getFlags(bottomRightPixel.PixelID16_Charge8_Flags8);

        bool topLeftPixelSolid = bitsetHas(topLeftPixelFlags, Solid);
        bool topRightPixelSolid = bitsetHas(topRightPixelFlags, Solid);
        bool bottomLeftPixelSolid = bitsetHas(bottomLeftPixelFlags, Solid);
        bool bottomRightPixelSolid = bitsetHas(bottomRightPixelFlags, Solid);

        bool topLeftPixelConnected = bitsetHas(topLeftPixelFlags, Connected);
        bool topRightPixelConnected = bitsetHas(topRightPixelFlags, Connected);
        bool bottomLeftPixelConnected = bitsetHas(bottomLeftPixelFlags, Connected);
        bool bottomRightPixelConnected = bitsetHas(bottomRightPixelFlags, Connected);

        for (int segmentsTypeIndex = 0; segmentsTypeIndex < 2; segmentsTypeIndex++)
        {
            uint caseNumber = 16;

            if (segmentsTypeIndex == 0)
            {
                caseNumber = (uint(topLeftPixelSolid && topLeftPixelConnected) << 3u) |
                (uint(topRightPixelSolid && topRightPixelConnected) << 2u) |
                (uint(bottomRightPixelSolid && bottomRightPixelConnected) << 1u) |
                uint(bottomLeftPixelSolid && bottomLeftPixelConnected);
            }
            else
            {
                caseNumber = (uint(topLeftPixelSolid && !topLeftPixelConnected) << 3u) |
                (uint(topRightPixelSolid && !topRightPixelConnected) << 2u) |
                (uint(bottomRightPixelSolid && !bottomRightPixelConnected) << 1u) |
                uint(bottomLeftPixelSolid && !bottomLeftPixelConnected);
            }

            uint caseIndex = caseLookup[caseNumber];

            // TODO: fix diagonals for more performance
            // Add handling for diagonal cases
            bool forceCaseSwitch = false;
            if (direction == DiagonalLeftToRight || direction == DiagonalRightToLeft) {
                if (
                (caseIndex >= 7) ||
                (previousCaseIndex[segmentsTypeIndex] == 3 && (caseIndex == 3)) ||
                (previousCaseIndex[segmentsTypeIndex] == 6 && (caseIndex == 6)) ||
                (previousCaseIndex[segmentsTypeIndex] == 4 && (caseIndex == 4)) ||
                (previousCaseIndex[segmentsTypeIndex] == 5 && (caseIndex == 5))) {
                    forceCaseSwitch = true;
                }
            }

            if (caseIndex != previousCaseIndex[segmentsTypeIndex] || forceCaseSwitch)
            {
                bool isInvalidCase = caseIndex != 0 && ((direction == Vertical && caseIndex != 1) ||
                (direction == Horizontal && caseIndex != 2) ||
                (direction == DiagonalLeftToRight && caseIndex != 3 && caseIndex != 4 && caseIndex != 7) ||
                (direction == DiagonalRightToLeft && caseIndex != 5 && caseIndex != 6 && caseIndex != 8));

                if (previousCaseIndex[segmentsTypeIndex] == 16)
                {
                    if (!isInvalidCase)
                    {
                        previousCaseIndex[segmentsTypeIndex] = caseIndex;
                        previousCaseNumber[segmentsTypeIndex] = caseNumber;
                        startPosition[segmentsTypeIndex] = samplePosition;
                    }
                }
                else
                {
                    const int[4] edges = edgeLookup[previousCaseIndex[segmentsTypeIndex]];

                    for (int i = 0; i < 4; i += 2)
                    {
                        if (edges[i] != -1 && edges[i + 1] != -1)
                        {
                            vec2 start;
                            vec2 end;
                            bool connectionCase = connectionLookup[previousCaseNumber[segmentsTypeIndex]][i / 2];

                            if (connectionCase)
                            {
                                start = previousPosition[segmentsTypeIndex] + edgeOffsets[edges[i]] + vec2(0.5, -0.5);
                                end = startPosition[segmentsTypeIndex] + edgeOffsets[edges[i + 1]] + vec2(0.5, -0.5);
                            }
                            else
                            {
                                start = startPosition[segmentsTypeIndex] + edgeOffsets[edges[i]] + vec2(0.5, -0.5);
                                end = previousPosition[segmentsTypeIndex] + edgeOffsets[edges[i + 1]] + vec2(0.5, -0.5);
                            }

                            uint idx = 0;
                            if (segmentsTypeIndex == 0) {
                                idx = atomicAdd(numConnectedSegments, 1);
                            }
                            else {
                                idx = atomicAdd(numSolidSegments, 1);
                            }
                            uint offset = segmentsTypeIndex * NumMarchingSquareSegments;
                            segments[offset + (idx * 2)] = targetOffset + start;
                            segments[offset + ((idx * 2) + 1)] = targetOffset + end;
                        }
                    }

                    if (isInvalidCase)
                    {
                        previousCaseIndex[segmentsTypeIndex] = 16;
                        previousCaseNumber[segmentsTypeIndex] = 16;
                    }
                    else
                    {
                        previousCaseIndex[segmentsTypeIndex] = caseIndex;
                        previousCaseNumber[segmentsTypeIndex] = caseNumber;
                        startPosition[segmentsTypeIndex] = samplePosition;
                    }
                }
            }

            previousPosition[segmentsTypeIndex] = samplePosition;
        }
    }
}