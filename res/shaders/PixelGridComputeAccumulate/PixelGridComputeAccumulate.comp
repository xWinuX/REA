#version 450

#include "../PixelGridComputeGlobals.glsl"


layout (push_constant) uniform PushConstant {
    uint readIndex;
    uint writeIndex;
};

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main()
{
    uint simulationWidth = simulationData.simulationWidth;
    uint simulationHeight = simulationData.simulationHeight;

    if (gl_GlobalInvocationID.x >= simulationWidth * simulationHeight) {
        return;
    }

    uint x = gl_GlobalInvocationID.x % simulationWidth;
    uint y = gl_GlobalInvocationID.x / simulationWidth;

    uint topY = (y + 1) % simulationHeight;
    uint bottomY = (y == 0) ? simulationHeight - 1 : y - 1;

    uint rightX = (x + 1) % simulationWidth;
    uint leftX = (x == 0) ? simulationWidth - 1 : x - 1;

    // Calculate wrapped indices
    uvec2 readOffset = uvec2(0, 0);
    uvec2 writeOffset = uvec2(0, 0);

    uint readWidth = simulationWidth;
    uint writeWidth = simulationWidth;

    if (readIndex == 0) {
        readOffset = uvec2(simulationData.targetPosition);
        readWidth = simulationData.width;
    }

    if (writeIndex == 0) {
        writeOffset = uvec2(simulationData.targetPosition);
        writeWidth = simulationData.width;
    }

    uint topYCalc = topY * simulationWidth;
    uint middleYCalc = y * simulationWidth;
    uint bottomYCalc = bottomY * simulationWidth;

    uint topLeftIndex = getGlobalIndex(leftX, topY, readWidth, readOffset) + readIndex;
    uint topCenterIndex = getGlobalIndex(x, topY, readWidth, readOffset) + readIndex;
    uint topRightIndex = getGlobalIndex(rightX, topY, readWidth, readOffset) + readIndex;

    uint middleLeftIndex = getGlobalIndex(leftX, y, readWidth, readOffset) + readIndex;
    uint middleCenterIndex = getGlobalIndex(x, y, readWidth, readOffset) + readIndex;
    uint middleRightIndex = getGlobalIndex(rightX, y, readWidth, readOffset) + readIndex;

    uint bottomLeftIndex = getGlobalIndex(leftX, bottomY, readWidth, readOffset) + readIndex;
    uint bottomCenterIndex = getGlobalIndex(x, bottomY, readWidth, readOffset) + readIndex;
    uint bottomRightIndex = getGlobalIndex(rightX, bottomY, readWidth, readOffset) + readIndex;

    // Read pixels
    Pixel topLeftPixel = pixels[topLeftIndex];
    Pixel topCenterPixel = pixels[topCenterIndex];
    Pixel topRightPixel = pixels[topRightIndex];

    Pixel middleLeftPixel = pixels[middleLeftIndex];
    Pixel middleCenterPixel = pixels[middleCenterIndex];
    Pixel middleRightPixel = pixels[middleRightIndex];

    Pixel bottomLeftPixel = pixels[bottomLeftIndex];
    Pixel bottomCenterPixel = pixels[bottomCenterIndex];
    Pixel bottomRightPixel = pixels[bottomRightIndex];

    uint pixelID = middleCenterPixel.PixelID16_Charge8_Flags8 & 0xFFFFu;

    PixelData middleCenterPixelData = simulationData.pixelLookup[pixelID];

    uint charge = getCharge(middleCenterPixel.PixelID16_Charge8_Flags8);
    uint flags = getFlags(middleCenterPixel.PixelID16_Charge8_Flags8);

/* if (charge > 0 && bitsetHas(middleCenterPixelData.Flags, ElectricityReceiver))
     {
         charge--;
     }*/


    if (bitsetHas(middleCenterPixelData.Flags, Electricity))
    {
        int aroundCharge = 0;

        uint maxCharge0 = max(getCharge(middleRightPixel.PixelID16_Charge8_Flags8), getCharge(topCenterPixel.PixelID16_Charge8_Flags8));
        uint maxCharge1 = max(getCharge(middleLeftPixel.PixelID16_Charge8_Flags8), getCharge(bottomCenterPixel.PixelID16_Charge8_Flags8));

        uint maxCharge = max(maxCharge0, maxCharge1);

        if (!bitsetHas(middleCenterPixelData.Flags, ElectricityEmitter)) {
            charge = uint(clamp(int(maxCharge) - 1, 0, 255));
        }
    }

    float temperatureResistance = middleCenterPixelData.TemperatureResistance;

    float baseTemperature = middleCenterPixel.Temperature;
    float temperature = baseTemperature;

    temperature += topLeftPixel.Temperature;
    temperature += topCenterPixel.Temperature;
    temperature += topRightPixel.Temperature;
    temperature += middleLeftPixel.Temperature;
    temperature += middleRightPixel.Temperature;
    temperature += bottomLeftPixel.Temperature;
    temperature += bottomCenterPixel.Temperature;
    temperature += bottomRightPixel.Temperature;

    temperature /= 9.0f;

    temperature = mix(baseTemperature, temperature, temperatureResistance);

    if (temperature >= middleCenterPixelData.HighTemperatureLimit) {
        pixelID = middleCenterPixelData.HighTemperatureLimitPixelID;
        PixelData newPixelData = simulationData.pixelLookup[pixelID];
        flags &= newPixelData.FlagsCarryover;
        temperature = mix(temperature, newPixelData.BaseTemperature, newPixelData.TemperatureConversion);

        uint rigidBodyID = getRigidBodyID(middleCenterPixel.RigidBodyID12_RigidBodyIndex20);
        if (rigidBodyID != 0)
        {
            rigidBodies[rigidBodyID].NeedsRecalculation = true;
        }

    } else if (temperature < middleCenterPixelData.LowerTemperatureLimit) {
        pixelID = middleCenterPixelData.LowerTemperatureLimitPixelID;
        PixelData newPixelData = simulationData.pixelLookup[pixelID];
        flags &= newPixelData.FlagsCarryover;
        temperature = mix(temperature, newPixelData.BaseTemperature, newPixelData.TemperatureConversion);

        uint rigidBodyID = getRigidBodyID(middleCenterPixel.RigidBodyID12_RigidBodyIndex20);
        if (rigidBodyID != 0)
        {
            rigidBodies[rigidBodyID].NeedsRecalculation = true;
        }
    }

    // Clear Info
    middleCenterPixel.PixelID16_Charge8_Flags8 &= 0x00000000u;

    // Assign new info
    middleCenterPixel.PixelID16_Charge8_Flags8 |= pixelID;
    middleCenterPixel.PixelID16_Charge8_Flags8 |= charge << 16u;
    middleCenterPixel.PixelID16_Charge8_Flags8 |= flags << 24u;
    middleCenterPixel.Temperature = temperature;

    // Write pixels to output and rendering buffer
    uint middleCenterIndexWrite = getGlobalIndex(x, y, writeWidth, writeOffset) + writeIndex;
    uint middleCenterIndexWriteRead = getGlobalIndex(x, y, simulationWidth, uvec2(0, 0));
    pixels[middleCenterIndexWrite] = middleCenterPixel;

    readOnlyPixels[middleCenterIndexWriteRead] = middleCenterPixel;
}
