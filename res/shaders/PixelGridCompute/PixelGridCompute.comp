#version 450

#include "../PixelGridComputeGlobals.glsl"

// Pixel with {PixelID: 255, Flags: [Solid], Density: minValue, Spread: 0}
//const Pixel solidPixel = { 0x000001FF };
//const Pixel solidPixel = { 0xFF01F000 };

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main()
{
    uint index = gl_GlobalInvocationID.x;

    if (index >= width * height) {
        return;
    }

    uint y = index / width;
    uint x = index % height;

    Pixel solidPixel = simulationData.solidPixel;
    Pixel currentPixel = readOnlyPixels[index];

    uint currentPixelFlags = getPixelFlags(currentPixel.PixelID8_Flags8_Density8_Spread8);
    uint currentPixelDensity = getPixelDensity(currentPixel.PixelID8_Flags8_Density8_Spread8);

    if (bitsetHas(currentPixelFlags, Gravity))
    {
        bool atTheBottom = y == 0;
        bool atTheTop    = y == height - 1;

        uint topIndex    = (y + 1) * width + x;
        uint bottomIndex = (y - 1) * width + x;

        // Middle
        Pixel topPixel = solidPixel;
        if (!atTheTop) { topPixel = readOnlyPixels[topIndex]; }

        Pixel bottomPixel = solidPixel;
        if (!atTheBottom) { bottomPixel = readOnlyPixels[bottomIndex]; }

        Pixel rightPixel       = solidPixel;
        Pixel topRightPixel    = solidPixel;
        Pixel bottomRightPixel = solidPixel;

        Pixel leftPixel       = solidPixel;
        Pixel topLeftPixel    = solidPixel;
        Pixel bottomLeftPixel = solidPixel;

        // Right
        if (x + 1 < width)
        {
            rightPixel = readOnlyPixels[index + 1];

            if (!atTheTop) { topRightPixel = readOnlyPixels[topIndex + 1]; }

            if (!atTheBottom) { bottomRightPixel = readOnlyPixels[bottomIndex + 1]; }
        }

        // Left
        if (x - 1 > 0)
        {
            leftPixel = readOnlyPixels[index - 1];

            if (!atTheTop) { topLeftPixel = readOnlyPixels[topIndex - 1]; }

            if (!atTheBottom) { bottomLeftPixel = readOnlyPixels[bottomIndex - 1]; }
        }

        uint topPixelFlags = getPixelFlags(topPixel.PixelID8_Flags8_Density8_Spread8);
        uint topPixelDensity = getPixelDensity(topPixel.PixelID8_Flags8_Density8_Spread8);

        uint bottomPixelFlags = getPixelFlags(bottomPixel.PixelID8_Flags8_Density8_Spread8);
        uint bottomPixelDensity = getPixelDensity(bottomPixel.PixelID8_Flags8_Density8_Spread8);

        if (!bitsetHas(topPixelFlags, Solid) && currentPixelDensity < topPixelDensity)
        {
            pixels[index] = topPixel;
            return;
        }

        if (!bitsetHas(bottomPixelFlags, Solid) && currentPixelDensity > bottomPixelDensity)
        {
            pixels[index] = bottomPixel;
            return;
        }

        if (simulationData.timer % 2 == 0)
        {
            uint rightPixelFlags = getPixelFlags(rightPixel.PixelID8_Flags8_Density8_Spread8);
            uint rightPixelDensity = getPixelDensity(rightPixel.PixelID8_Flags8_Density8_Spread8);

            uint leftPixelFlags = getPixelFlags(leftPixel.PixelID8_Flags8_Density8_Spread8);
            uint leftPixelDensity = getPixelDensity(leftPixel.PixelID8_Flags8_Density8_Spread8);

            uint topLeftPixelFlags = getPixelFlags(topLeftPixel.PixelID8_Flags8_Density8_Spread8);
            uint topLeftPixelDensity = getPixelFlags(topLeftPixel.PixelID8_Flags8_Density8_Spread8);

            if (!bitsetHas(topLeftPixelFlags, Solid) &&
            !bitsetHas(topPixelFlags, Solid) &&// If top left is not solid meaning it can flow
            leftPixelDensity >= topLeftPixelDensity &&// and top left will not swap with left
            currentPixelDensity < topLeftPixelDensity)// and can swap with current pixel
            {
                pixels[index] = topLeftPixel;
                return;
            }

            uint bottomRightPixelFlags = getPixelFlags(bottomRightPixel.PixelID8_Flags8_Density8_Spread8);
            uint bottomRightPixelDensity = getPixelDensity(bottomRightPixel.PixelID8_Flags8_Density8_Spread8);
            if (!bitsetHas(bottomRightPixelFlags, Solid) &&
            !bitsetHas(topPixelFlags, Solid) &&
            !bitsetHas(rightPixelFlags, Solid) &&
            rightPixelDensity <= bottomRightPixelDensity &&
            currentPixelDensity > bottomRightPixelDensity)
            {
                pixels[index] = bottomRightPixel;
                return;
            }
        }
        else
        {
            uint leftPixelFlags = getPixelFlags(leftPixel.PixelID8_Flags8_Density8_Spread8);
            uint leftPixelDensity = getPixelDensity(leftPixel.PixelID8_Flags8_Density8_Spread8);

            uint rightPixelFlags = getPixelFlags(rightPixel.PixelID8_Flags8_Density8_Spread8);
            uint rightPixelDensity = getPixelDensity(rightPixel.PixelID8_Flags8_Density8_Spread8);

            uint topRightPixelFlags = getPixelFlags(topRightPixel.PixelID8_Flags8_Density8_Spread8);
            uint topRightPixelDensity = getPixelFlags(topRightPixel.PixelID8_Flags8_Density8_Spread8);

            if (!bitsetHas(topRightPixelFlags, Solid) &&// If top right is not solid meaning it can flow
            !bitsetHas(topPixelFlags, Solid) &&// If top left is not solid meaning it can flow
            rightPixelDensity >= topRightPixelDensity &&// and top right will not swap with right
            currentPixelDensity < topRightPixelDensity)// and can swap with current pixel
            {
                pixels[index] = topRightPixel;
                return;
            }

            uint bottomLeftPixelFlags = getPixelFlags(bottomLeftPixel.PixelID8_Flags8_Density8_Spread8);
            uint bottomLeftPixelDensity = getPixelDensity(bottomLeftPixel.PixelID8_Flags8_Density8_Spread8);
            if (!bitsetHas(bottomLeftPixelFlags, Solid) &&
            !bitsetHas(topPixelFlags, Solid) &&
            !bitsetHas(leftPixelFlags, Solid) &&
            leftPixelDensity <= bottomLeftPixelDensity &&
            currentPixelDensity > bottomLeftPixelDensity)
            {
                pixels[index] = bottomLeftPixel;
                return;
            }
        }
    }

    pixels[index] = currentPixel;
}