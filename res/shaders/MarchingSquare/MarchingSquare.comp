#version 450

#include "../PixelGridComputeGlobals.glsl"

layout (push_constant) uniform PushConstant {
    uint ReadIndex;
};

layout (std430, set = 1, binding = 5) writeonly buffer s_c_si_MarchingSquares {
    uint numConnectedSegments;
    uint numSolidSegments;
    vec2 segments[NumMarchingSquareSegments * 2];
};

const uint caseLookup[16] = {
0, // 0000 0
3, // 0001 1
5, // 0010 2
2, // 0011 3
4, // 0100 4
7, // 0101 5
1, // 0110 6
6, // 0111 7
6, // 1000 8
1, // 1001 9
8, // 1010 10
4, // 1011 11
2, // 1100 12
5, // 1101 13
3, // 1110 14
0, // 1111 15
};

const bool connectionLookup[16][2] = {
{ false, false }, // 0000 0
{ true, false }, // 0001 1
{ true, false }, // 0010 2
{ true, false }, // 0011 3
{ true, false }, // 0100 4
{ false, true }, // 0101 5
{ false, false }, // 0110 6
{ false, false }, // 0111 7
{ false, false }, // 1000 8
{ false, false }, // 1001 9
{ false, true }, // 1010 10
{ true, false }, // 1011 11
{ true, false }, // 1100 12
{ false, false }, // 1101 13
{ false, false }, // 1110 14
{ false, false }, // 1111 15
};



const int edgeLookup[9][4] = {
{ -1, -1, -1, -1 }, // Nothing 0
{ 0, 2, -1, -1 }, // Column 1
{ 1, 3, -1, -1 }, // Row 2
{ 0, 3, -1, -1 }, // Bottom Left Corner 3
{ 1, 2, -1, -1 }, // Top Right Corner 4
{ 0, 1, -1, -1 }, // Bottom Right Corner 5
{ 2, 3, -1, -1 }, // Top Left Corner 6
{ 0, 1, 2, 3 }, // Diagonal Top Right to Bottom Left 7
{ 0, 3, 1, 2 }// Diagonal Top Left to Bottom Right 9
};

const vec2 edgeOffsets[4] = vec2[4](
    vec2(0.5f, 0.0f), // 0 -> midpoint of edge between 0 and 1
    vec2(1.0f, 0.5f), // 1 -> midpoint of edge between 1 and 2
    vec2(0.5f, 1.0f), // 2 -> midpoint of edge between 2 and 3
    vec2(0.0f, 0.5f)// 3 -> midpoint of edge between 3 and 0
);




const uint Vertical = 0;
const uint Horizontal = 1;
const uint DiagonalLeftToRight = 2;
const uint DiagonalRightToLeft = 3;

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main()
{
    uint width = simulationData.width;
    uint height = simulationData.height;

    if (gl_GlobalInvocationID.x >= ((width + height) * 3) - 2) {
        return;
    }

    uint direction = Vertical;
    ivec2 stepDirection = ivec2(0, 1);// Which direction will the cells step to cover one column/row/diagonal
    uvec2 position = uvec2(gl_GlobalInvocationID.x, 0);// Starting position of the iteration
    uint numIterations = height;
    bool swapEndAndStart = false;

    // Vertical Iteration
    if (gl_GlobalInvocationID.x < width) {
        direction = Vertical;
        stepDirection = ivec2(0, 1);
        position = uvec2(gl_GlobalInvocationID.x, 0);
        numIterations = height;

        // Horizontal Iteration
    } else if (gl_GlobalInvocationID.x < width + height) {
        direction = Horizontal;
        stepDirection = ivec2(1, 0);
        position = uvec2(0, gl_GlobalInvocationID.x - width);
        numIterations = width;
        swapEndAndStart = true;
        // Diagonal Left to Right
    } else if (gl_GlobalInvocationID.x < width + height + (width + height - 1)) {
        direction = DiagonalLeftToRight;
        stepDirection = ivec2(1, -1);
        uint index = gl_GlobalInvocationID.x - (width + height);
        if (index < height) {
            position = uvec2(0, index);
            numIterations = min(index + 1, min(width, height));
        } else {
            position = uvec2(index - height + 1, height - 1);
            numIterations = min(width - (index - height + 1), height);
        }
        swapEndAndStart = true;

        // Diagonal Right to Left
    } else {
        direction = DiagonalRightToLeft;
        stepDirection = ivec2(-1, -1);
        uint index = gl_GlobalInvocationID.x - (width + height + (width + height - 1));
        if (index < height) {
            position = uvec2(width - 1, index);
            numIterations = min(index + 1, min(width, height));
        } else {
            position = uvec2(width - (index - height + 1), height - 1);
            numIterations = min(width - (index - height + 1), height);
        }
    }



    vec2 startPosition[2] = { vec2(0.0f), vec2(0.0f) };
    vec2 previousPosition[2] = { vec2(1.0f), vec2(1.0f) };
    uint previousCaseIndex[2] = { 16, 16 };
    uint previousCaseNumber[2] = { 16, 16 };

    for (int stepIndex = 0; stepIndex < numIterations; stepIndex++)
    {
        uint x = uint(position.x + stepDirection.x * stepIndex);
        uint y = uint(position.y + stepDirection.y * stepIndex);

        vec2 samplePosition = vec2(x, y);

        uint middleYCalc = y * width;

        uint bottomY = (y == 0) ? height - 1 : y - 1;
        uint rightX = (x + 1) % width;

        uint bottomYCalc = bottomY * width;

        uint topLeftIndex = middleYCalc + x;
        uint topRightIndex = middleYCalc + rightX;
        uint bottomLeftIndex = bottomYCalc + x;
        uint bottomRightIndex = bottomYCalc + rightX;

        Pixel topLeftPixel = pixels[topLeftIndex + ReadIndex];
        Pixel topRightPixel = pixels[topRightIndex + ReadIndex];
        Pixel bottomLeftPixel = pixels[bottomLeftIndex + ReadIndex];
        Pixel bottomRightPixel = pixels[bottomRightIndex + ReadIndex];

        uint topLeftPixelFlags = getFlags(topLeftPixel.PixelID16_Charge8_Flags8);
        uint topRightPixelFlags = getFlags(topRightPixel.PixelID16_Charge8_Flags8);
        uint bottomLeftPixelFlags = getFlags(bottomLeftPixel.PixelID16_Charge8_Flags8);
        uint bottomRightPixelFlags = getFlags(bottomRightPixel.PixelID16_Charge8_Flags8);

        bool topLeftPixelSolid = bitsetHas(topLeftPixelFlags, Solid);
        bool topRightPixelSolid = bitsetHas(topRightPixelFlags, Solid);
        bool bottomLeftPixelSolid = bitsetHas(bottomLeftPixelFlags, Solid);
        bool bottomRightPixelSolid = bitsetHas(bottomRightPixelFlags, Solid);

        bool topLeftPixelConnected = bitsetHas(topLeftPixelFlags, Connected);
        bool topRightPixelConnected = bitsetHas(topRightPixelFlags, Connected);
        bool bottomLeftPixelConnected = bitsetHas(bottomLeftPixelFlags, Connected);
        bool bottomRightPixelConnected = bitsetHas(bottomRightPixelFlags, Connected);

        for (int segmentsTypeIndex = 0; segmentsTypeIndex < 2; segmentsTypeIndex++)
        {
            uint caseNumber = 16;

            if (segmentsTypeIndex == 0)
            {
                caseNumber = (uint(topLeftPixelSolid && topLeftPixelConnected) << 3u) |
                (uint(topRightPixelSolid && topRightPixelConnected) << 2u) |
                (uint(bottomRightPixelSolid && bottomRightPixelConnected) << 1u) |
                uint(bottomLeftPixelSolid && bottomLeftPixelConnected);
            }
            else
            {
                caseNumber = (uint(topLeftPixelSolid && !topLeftPixelConnected) << 3u) |
                (uint(topRightPixelSolid && !topRightPixelConnected) << 2u) |
                (uint(bottomRightPixelSolid && !bottomRightPixelConnected) << 1u) |
                uint(bottomLeftPixelSolid && !bottomLeftPixelConnected);
            }

            uint caseIndex = caseLookup[caseNumber];

            // TODO: fix diagonals for more performance
            // Add handling for diagonal cases
            bool forceCaseSwitch = false;
            if (direction == DiagonalLeftToRight || direction == DiagonalRightToLeft) {
                if (
                (caseIndex >= 7) ||
                (previousCaseIndex[segmentsTypeIndex] == 3 && (caseIndex == 3)) ||
                (previousCaseIndex[segmentsTypeIndex] == 6 && (caseIndex == 6)) ||
                (previousCaseIndex[segmentsTypeIndex] == 4 && (caseIndex == 4)) ||
                (previousCaseIndex[segmentsTypeIndex] == 5 && (caseIndex == 5))) {
                    forceCaseSwitch = true;
                }
            }

            if (caseIndex != previousCaseIndex[segmentsTypeIndex] || forceCaseSwitch)
            {
                bool isInvalidCase = caseIndex != 0 && ((direction == Vertical && caseIndex != 1) ||
                (direction == Horizontal && caseIndex != 2) ||
                (direction == DiagonalLeftToRight && caseIndex != 3 && caseIndex != 4 && caseIndex != 7) ||
                (direction == DiagonalRightToLeft && caseIndex != 5 && caseIndex != 6 && caseIndex != 8));

                if (previousCaseIndex[segmentsTypeIndex] == 16)
                {
                    if (!isInvalidCase)
                    {
                        previousCaseIndex[segmentsTypeIndex] = caseIndex;
                        previousCaseNumber[segmentsTypeIndex] = caseNumber;
                        startPosition[segmentsTypeIndex] = samplePosition;
                    }
                }
                else
                {
                    const int[4] edges = edgeLookup[previousCaseIndex[segmentsTypeIndex]];

                    for (int i = 0; i < 4; i += 2)
                    {
                        if (edges[i] != -1 && edges[i + 1] != -1)
                        {
                            vec2 start;
                            vec2 end;
                            bool connectionCase = connectionLookup[previousCaseNumber[segmentsTypeIndex]][i / 2];

                            if (connectionCase)
                            {
                                start = previousPosition[segmentsTypeIndex] + edgeOffsets[edges[i]] + vec2(0.5, -0.5);
                                end = startPosition[segmentsTypeIndex] + edgeOffsets[edges[i + 1]] + vec2(0.5, -0.5);
                            }
                            else
                            {
                                start = startPosition[segmentsTypeIndex] + edgeOffsets[edges[i]] + vec2(0.5, -0.5);
                                end = previousPosition[segmentsTypeIndex] + edgeOffsets[edges[i + 1]] + vec2(0.5, -0.5);
                            }

                            uint idx = 0;
                            if (segmentsTypeIndex == 0) {
                                idx = atomicAdd(numConnectedSegments, 1);
                            }
                            else {
                                idx = atomicAdd(numSolidSegments, 1);
                            }
                            uint offset = segmentsTypeIndex * NumMarchingSquareSegments;
                            segments[offset + (idx * 2)] = start;
                            segments[offset + ((idx * 2) + 1)] = end;
                        }
                    }

                    if (isInvalidCase)
                    {
                        previousCaseIndex[segmentsTypeIndex] = 16;
                        previousCaseNumber[segmentsTypeIndex] = 16;
                    }
                    else
                    {
                        previousCaseIndex[segmentsTypeIndex] = caseIndex;
                        previousCaseNumber[segmentsTypeIndex] = caseNumber;
                        startPosition[segmentsTypeIndex] = samplePosition;
                    }
                }
            }

            previousPosition[segmentsTypeIndex] = samplePosition;
        }
    }
}